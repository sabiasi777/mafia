<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Mafia Game</title>
    <link rel="stylesheet" href="../assets/css/game.css">
</head>
<body>
    <a href="http://localhost:8080" class="home-link">‚Üê Mafia</a>
    
    <div class="container">
        <div id="gameScreen" class="game-card">
            <header>
                <h1>Room: {{.Code}}</h1>
            </header>

            <div class="game-info" id="gameInfo">
                <div class="info-section">
                    <h2>Players <span class="player-count">{{len .Players}}</span></h2>
                    <ul class="player-list" id="playerList">
                        {{range .Players}}
                            <li class="player-item {{if .IsActive}}active{{end}}">{{.Name}}</li>
                        {{end}}
                    </ul>
                </div>

                {{ if .ActiveRoles }}
                    <div class="info-section">
                        <h2>Active Roles</h2>
                        <ul class="role-list" id="roleList">
                            {{range .ActiveRoles}}
                                <li class="role-item">{{.}}</li>
                            {{end}}
                        </ul>
                    </div>
                {{ else }}
                    <div class="warning">
                        ‚ö†Ô∏è Not enough players to start the game. Minimum: 4
                    </div>
                {{ end }}
            </div>

            <button class="start-button" id="startButton" type="button" disabled>
                üéÆ Start Game
            </button>

            <div class="status-bar" id="statusBar">
                Waiting for players to join...
            </div>
        </div>
    </div>

    <div id="roleContainer" class="role-reveal">
        <div class="role-text" id="roleText"></div>
    </div>

    <div id="gameArea" class="game-area">
        <div class="chat-container">
            <div id="messages" class="messages"></div>
            <div class="chat-input">
                <input type="text" id="messageInput" class="message-input" placeholder="Type your message...">
                <button id="sendButton" class="send-button">Send</button>
            </div>
        </div>
        <button id="microphoneButton" class="mic-button muted">üîá</button>
    </div>

<script>
        const startButton = document.getElementById("startButton")
        const playerList = document.getElementById("playerList")
        const roleContainer = document.getElementById('roleContainer');
        const roleText = document.getElementById('roleText');
        const gameArea = document.getElementById('gameArea');
        const gameScreen = document.getElementById('gameScreen');
        const sendButton = document.getElementById("sendButton")
        const microphoneButton = document.getElementById("microphoneButton")

        var roomCode
        var ws
        var stream
        var mediaRecorder

        var micMode = false
        var audioQueue = []
        var audioContext
        var isPlaying = false
        var nextPlaybackTime = 0
        var audioChunks

        startButton.addEventListener('click', () => {
            roomCode = window.location.pathname.split("/").pop()
            fetch("http://localhost:8080/start", {
                method: "POST",
                headers: {
                    'Content-Type': "application/json"
                },
                body: JSON.stringify({ roomCode })
            })
            .then(res => {
                if (!res.ok) throw new Error("Failed to start game")
                return res.json()
            })
            .then(data => {
                connect()
                const currentUser = getCurrentUserNameFromURL()
                const me = data.find(p => p.name === currentUser)
                if (me) {
                    startGameUI(me)
                }
            })
            .catch(err => console.error(err))
        })

        sendButton.addEventListener("click", () => {
            const input = document.getElementById("messageInput")
            if (input.value.trim()) {
                const currentUser = getCurrentUserNameFromURL()
                const messageData = {
                    sender: currentUser,
                    content: input.value.trim(),
                    timestamp: new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}),
                    type: "text"
                }
                ws.send(JSON.stringify(messageData))
                input.value = ""
            }
        })

        document.getElementById("messageInput").addEventListener("keypress", (e) => {
            if (e.key === "Enter") {
                sendButton.click()
            }
        })

        microphoneButton.addEventListener("click", toggleMicrophone)

        function checkPlayerCount() {
            const playerCount = playerList.querySelectorAll("li").length
            const countElement = document.querySelector('.player-count');
            if (countElement) {
                countElement.textContent = playerCount;
            }
            startButton.disabled = playerCount < 4
            
            if (playerCount >= 4) {
                startButton.innerHTML = 'üéÆ Start Game';
            } else {
                startButton.innerHTML = `üéÆ Need ${4 - playerCount} more players`;
            }
        }

        checkPlayerCount()

        const observer = new MutationObserver(checkPlayerCount)
        observer.observe(playerList, { childList: true })

        function getCurrentUserNameFromURL() {
            const params = new URLSearchParams(window.location.search)
            return params.get("user")
        }

        function startGameUI(me) {
            document.getElementById("gameInfo").style.display = "none"
            document.getElementById("statusBar").style.display = "none"
            document.getElementsByTagName("header")[0].style.display = "none"
            startButton.style.display = "none"

            roleText.textContent = `Your role: ${me.role}`
            roleContainer.style.display = "flex"

            setTimeout(() => {
                roleContainer.style.display = "none"
                gameArea.style.display = "block"
            }, 3000)
        }

        // async function toggleMicrophone() {
        //     if (!stream || !mediaRecorder) {
        //         await setupAudio()
        //     }

        //     micMode = !micMode

        //     if (micMode) {
        //         mediaRecorder.start(1000)
        //         console.log("Live streaming started")
        //         microphoneButton.className = "mic-button unmuted"
        //         microphoneButton.textContent = "üéôÔ∏è"
        //     } else {
        //         mediaRecorder.stop()
        //         console.log("Live streaming stopped")
        //         microphoneButton.className = "mic-button muted"
        //         microphoneButton.textContent = "üîá"
        //     }
        // }

        // function connect() {
        //     ws = new WebSocket(`ws://localhost:8080/ws/chat?room=${roomCode}`)
        //     // ws.binaryType = "arraybuffer"

        //     ws.onopen = function() {
        //         console.log("Connected to WebSocket server")
        //     }

        //     ws.onmessage = async function(event) {
        //         const message = JSON.parse(event.data)
        //         if (message.audio && message.mimeType) {
        //             console.log("Audio message received")
        //             const url = URL.createObjectURL(message.audio)
        //             const audio = new Audio(url)

        //             audio.play()
        //         } else {
        //             console.log("Text message received")
        //             const messageDisplay = document.getElementById("messages")
        //             const messageElement = document.createElement("div")
        //             messageElement.className = "message"
        //             messageElement.innerHTML = `
        //                 <div class="message-sender">${message.sender}</div>
        //                 <div class="message-content">${message.content}</div>
        //                 <div class="message-time">${message.timestamp}</div>
        //             `
                    
        //             messageDisplay.appendChild(messageElement)
        //             messageDisplay.scrollTop = messageDisplay.scrollHeight
        //         }
        //     }

        //     ws.onclose = function() {
        //         console.log("WebSocket connection closed, retrying...")
        //         setTimeout(connect, 1000)
        //     }

        //     ws.onerror = function(error) {
        //         console.error("WebSocket error:", error)
        //     }
        // }

        // async function setupAudio() {
        //     if (!stream) {
        //         stream = await navigator.mediaDevices.getUserMedia({ audio: true })
        //         }
        //     if (!mediaRecorder) {
        //         mediaRecorder = new MediaRecorder(stream, { mimeType: "audio/webm;codecs=opus" })

        //         mediaRecorder.ondataavailable = async (e) => {
        //             if (e.data.size > 0) {
        //                 console.log("Sending audio chunk with type:", e.data.type, "and size:", e.data.size)
        //                 fetch("http://localhost:8080/audio", {
        //                     method: "POST",
        //                     headers: {
        //                         "Room-Code": roomCode,
        //                         "Content-Type": e.data.type,
        //                         'X-Mime-Type': e.data.type
        //                     },
        //                     body: e.data
        //                 })
        //                 .catch(err => console.error("Error sending audio chunk:", err))
        //             }
        //         }
        //     }
        // }

        async function toggleMicrophone() {
            if (!stream || !mediaRecorder) {
                await setupAudio()
            }

            micMode = !micMode

            if (micMode) {
                mediaRecorder.start(1000)
                console.log("Live streaming started")
                microphoneButton.className = "mic-button unmuted"
                microphoneButton.textContent = "üéôÔ∏è"
            } else {
                mediaRecorder.stop()
                console.log("Live streaming stopped")
                microphoneButton.className = "mic-button muted"
                microphoneButton.textContent = "üîá"
            }
        }

        // ... (Your checkPlayerCount, startButton, etc., functions go here) ...
        // I'm assuming you still have those. If you removed them,
        // you'll need to re-add necessary DOM element declarations (startButton, playerList, etc.)
        // and their event listeners, as well as `roomCode` handling.

        function connect() {
            ws = new WebSocket(`ws://localhost:8080/ws/chat?room=${roomCode}`)
            ws.binaryType = "arraybuffer"

            ws.onopen = function() {
                console.log("Connected to WebSocket server")
            }

            ws.onmessage = async function(event) {

                if (event.data instanceof arrayBuffer) {
                    console.log(`Received binary audio chunk. Length:${event.data.byteLength}`)

                    const audioBlob = new Blob([event.data], { type: "audio/webm;codecs=opus" })

                    audioQueue.push(audioBlob)
                    console.log("Audio Blob added to queue. Queue length:", audioQueue.length)

                    if (audioContext.state === "suspended") {
                        try {
                            await audioContext.resume()
                            console.log("AudioContext resumed by incoming audio chunk.")
                            isPlaying = true
                            processAudioQueue()
                        } catch (err) {
                            console.error("Failed to resume AudioContext on chunk arrival:", err)
                            isPlaying = false
                        }
                    } else if (audioContext.state === "running" && !isPlaying) {
                        isPlaying = true
                        processAudioQueue()
                    } else if (audioContext.state === "running" & isPlaying) {
                        processAudioQueue()
                    } else {
                        console.warn("Received unknown message type from websocket:", typeof event.data)
                    }
                } else if (typeof event.data === "string") {
                    const message = JSON.parse(event.data)
                    console.log("Text message received:", message)
                    const messageDisplay = document.getElementById("messages")
                    const messageElement = document.createElement("div")
                    messageElement.className = "message"
                    messageElement.innerHTML = `
                        <div class="message-sender">${message.sender}</div>
                        <div class="message-content">${message.content}</div>
                        <div class="message-time">${message.timestamp}</div>
                    `
                    messageDisplay.appendChild(messageElement)
                    messageDisplay.scrollTop = messageDisplay.scrollHeight
                }
            }

            ws.onclose = function() {
                console.log("WebSocket connection closed, retrying...")
                setTimeout(connect, 1000)
            }

            ws.onerror = function(error) {
                console.error("WebSocket error:", error)
            }
        }

        async function setupAudio() {
            if (!stream) {
                stream = await navigator.mediaDevices.getUserMedia({ audio: true })
            }
            if (!mediaRecorder) {
                mediaRecorder = new MediaRecorder(stream, { mimeType: "audio/webm;codecs=opus" })

                mediaRecorder.ondataavailable = async (e) => {
                    if (e.data.size > 0) {
                        console.log("Sending audio chunk with type:", e.data.type, "and size:", e.data.size)
                        fetch("http://localhost:8080/audio", {
                            method: "POST",
                            headers: {
                                "Room-Code": roomCode,
                                "Content-Type": e.data.type,
                                'X-Mime-Type': e.data.type
                            },
                            body: e.data
                        })
                        .catch(err => console.error("Error sending audio chunk:", err))
                    }
                }
            }
            
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)()
                nextPlaybackTime = audioContext.currentTime;
            }
        }
        
        async function processAudioQueue() {
            if (!isPlaying || audioQueue.length === 0) {
                return
            }

            while (audioQueue.length > 0 && nextPlaybackTime < audioContext.currentTime + 0.5) {
                const audioBlob = audioQueue.shift()

                try {
                    const arrayBuffer = await audioBlob.arrayBuffer()
                    console.log("Attempting to decode ArrayBuffer with byteLength:", arrayBuffer.byteLength);
                    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer)

                    const source = audioContext.createBufferSource()
                    source.buffer = audioBuffer
                    source.connect(audioContext.destination)

                    source.start(nextPlaybackTime)

                    nextPlaybackTime += audioBuffer.duration

                    source.onended = () => {
                        if (audioQueue.length === 0 && isPlaying) {
                            nextPlaybackTime = audioContext.currentTime;
                            console.warn("Playback buffer ran dry on onended. Resetting playback time.");
                        }
                    }

                } catch (err) {
                    console.error("Error decoding or playing audio chunk:", err)
                    nextPlaybackTime = audioContext.currentTime // Reset on error to avoid compounding
                }
            }
        }
    </script>
</body>
</html>
