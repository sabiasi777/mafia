<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Mafia Game</title>
    <link rel="stylesheet" href="../assets/css/game.css">
</head>
<body>
    <a href="http://localhost:8080" class="home-link">‚Üê Mafia</a>
    
    <div class="container">
        <div id="gameScreen" class="game-card">
            <header>
                <h1>Room: {{.Code}}</h1>
            </header>

            <div class="game-info" id="gameInfo">
                <div class="info-section">
                    <h2>Players <span class="player-count">{{len .Players}}</span></h2>
                    <ul class="player-list" id="playerList">
                        {{range .Players}}
                            <li class="player-item {{if .IsActive}}active{{end}}">{{.Name}}</li>
                        {{end}}
                    </ul>
                </div>

                {{ if .ActiveRoles }}
                    <div class="info-section">
                        <h2>Active Roles</h2>
                        <ul class="role-list" id="roleList">
                            {{range .ActiveRoles}}
                                <li class="role-item">{{.}}</li>
                            {{end}}
                        </ul>
                    </div>
                {{ else }}
                    <div class="warning">
                        ‚ö†Ô∏è Not enough players to start the game. Minimum: 4
                    </div>
                {{ end }}
            </div>

            <button class="start-button" id="startButton" type="button" disabled>
                üéÆ Start Game
            </button>

            <div class="status-bar" id="statusBar">
                Waiting for players to join...
            </div>
        </div>
    </div>

    <div id="roleContainer" class="role-reveal">
        <div class="role-text" id="roleText"></div>
    </div>

    <div id="gameArea" class="game-area">
        <div class="chat-container">
            <div id="messages" class="messages"></div>
            <div class="chat-input">
                <input type="text" id="messageInput" class="message-input" placeholder="Type your message...">
                <button id="sendButton" class="send-button">Send</button>
            </div>
        </div>
        <button id="microphoneButton" class="mic-button muted">üîá</button>
    </div>

    <script>
        const startButton = document.getElementById("startButton")
        const playerList = document.getElementById("playerList")
        const roleContainer = document.getElementById('roleContainer');
        const roleText = document.getElementById('roleText');
        const gameArea = document.getElementById('gameArea');
        const gameScreen = document.getElementById('gameScreen');
        const sendButton = document.getElementById("sendButton")
        const microphoneButton = document.getElementById("microphoneButton")
        
        var roomCode
        var ws
        var stream
        var mediaRecorder

        var micMode = false
        var audioQueue = []
        var audioContext
        var scriptProcessor
        var isPlaying = false

        async function toggleMicrophone() {
            if (!stream || !mediaRecorder) {
                await setupAudio()
            }

            micMode = !micMode

            if (micMode) {
                mediaRecorder.start(1000)
                console.log("Live streaming started")
                microphoneButton.className = "mic-button unmuted"
                microphoneButton.textContent = "üéôÔ∏è"
            } else {
                mediaRecorder.stop()
                console.log("Live streaming stopped")
                microphoneButton.className = "mic-button muted"
                microphoneButton.textContent = "üîá"
            }
        }

        function checkPlayerCount() {
            const playerCount = playerList.querySelectorAll("li").length
            const countElement = document.querySelector('.player-count');
            if (countElement) {
                countElement.textContent = playerCount;
            }
            startButton.disabled = playerCount < 4
            
            if (playerCount >= 4) {
                startButton.innerHTML = 'üéÆ Start Game';
            } else {
                startButton.innerHTML = `üéÆ Need ${4 - playerCount} more players`;
            }
        }

        checkPlayerCount()

        const observer = new MutationObserver(checkPlayerCount)
        observer.observe(playerList, { childList: true })

        startButton.addEventListener('click', () => {
            roomCode = window.location.pathname.split("/").pop()
            fetch("http://localhost:8080/start", {
                method: "POST",
                headers: {
                    'Content-Type': "application/json"
                },
                body: JSON.stringify({ roomCode })
            })
            .then(res => {
                if (!res.ok) throw new Error("Failed to start game")
                return res.json()
            })
            .then(data => {
                connect()
                const currentUser = getCurrentUserNameFromURL()
                const me = data.find(p => p.name === currentUser)
                if (me) {
                    startGameUI(me)
                }
            })
            .catch(err => console.error(err))
        })

        function getCurrentUserNameFromURL() {
            const params = new URLSearchParams(window.location.search)
            return params.get("user")
        }

        function startGameUI(me) {
            document.getElementById("gameInfo").style.display = "none"
            document.getElementById("statusBar").style.display = "none"
            document.getElementsByTagName("header")[0].style.display = "none"
            startButton.style.display = "none"

            roleText.textContent = `Your role: ${me.role}`
            roleContainer.style.display = "flex"

            setTimeout(() => {
                roleContainer.style.display = "none"
                gameArea.style.display = "block"
            }, 3000)
        }

        sendButton.addEventListener("click", () => {
            const input = document.getElementById("messageInput")
            if (input.value.trim()) {
                const currentUser = getCurrentUserNameFromURL()
                const messageData = {
                    sender: currentUser,
                    content: input.value.trim(),
                    timestamp: new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}),
                    type: "text"
                }
                ws.send(JSON.stringify(messageData))
                input.value = ""
            }
        })

        document.getElementById("messageInput").addEventListener("keypress", (e) => {
            if (e.key === "Enter") {
                sendButton.click()
            }
        })

        microphoneButton.addEventListener("click", toggleMicrophone)

        function connect() {
            ws = new WebSocket(`ws://localhost:8080/ws/chat?room=${roomCode}`)

            ws.onopen = function() {
                console.log("Connected to WebSocket server")
            }

            ws.onmessage = async function(event) {
                const parsed = JSON.parse(event.data)

                if (parsed.mimeType && parsed.audio) {
                    console.log(`Received audio chunk. Type: ${parsed.mimeType}. Length: ${parsed.audio.length}`)

                    var audioBlob
                    if(typeof parsed.auido === "string" && parsed.audio.startsWith("data:")) {
                        const parts = parsed.audio.split(",")
                        const mimeType = parts[0].match(/:(.*?);/)[1]
                        const base64 = parts[1]
                        const binaryString = atob(base64)
                        const len = binaryString.length
                        const bytes = new Uint8Array(len)
                        for (var i = 0; i < len; i++) {
                            bytes[i] = binaryString.charCodeAt(i)
                        }
                        audioBlob = new Blob([bytes.buffer], { type: mimeType })
                    }
                } else if (typeof parsed.audio === "string") {
                    const binaryString = atob(parsed.audio)
                    const len = binaryString.length
                    const bytes = new Uint8Array(len)
                    for (var i = 0; i < len; i++) {
                        bytes[i] = binaryString.charCodeAt(i)
                    }
                    audioBlob = new Blob([bytes.buffer], { type: parsed.mimeType })
                } else if (parsed.audio instanceof ArrayBuffer || parsed.audio instanceof Uint8Array) {
                    audioBlob = new Blob([parsed.audio], { type: parsed.mimeType }) 
                } else if (parsed.audio instanceof Blob) {
                    audioBlob = parsed.audio
                }
                else {
                    console.log("TEXT MESSAGE!")
                    const message = JSON.parse(event.data)
                    const messageDisplay = document.getElementById("messages")
                    const messageElement = document.createElement("div")
                    messageElement.className = "message"
                    messageElement.innerHTML = `
                        <div class="message-sender">${message.sender}</div>
                        <div class="message-content">${message.content}</div>
                        <div class="message-time">${message.timestamp}</div>
                    `
                    
                    messageDisplay.appendChild(messageElement)
                    messageDisplay.scrollTop = messageDisplay.scrollHeight
                }

                audioQueue.push(audioBlob)

                if (!isPlaying && audioQueue.length > 0) {
                    isPlaying = true
                    
                    if (audioContext.state === "suspended") {
                        await audioContext.resume()
                    }
                }
            }

            ws.onclose = function() {
                console.log("WebSocket connection closed, retrying...")
                setTimeout(connect, 1000)
            }

            ws.onerror = function(error) {
                console.error("WebSocket error:", error)
            }
        }

        function startPlayback() {
            if (audioContext && audioContext.state === "suspended") {
                audioContext.resume().then(() => {
                    console.log("AudioContext resumed. Playback started")
                    isPlaying = true
                })
            } else if (audioContext && audioContext.state === "running") {
                isPlaying = true
                console.log("AudioContext already running. Playback active")
            } else {
                console.log("AudioContext not initialized or in an unexpected state.")
            }
        }

        function stopPlayback() {
            isPlaying = false
            audioQueue = []

            if (audioContext && audioContext.state === "running") {
                audioContext.suspend().then(() => {
                    console.log("AudioContext suspended. Playback stopped")
                })
            }
        }

        async function setupAudio() {
            if (!stream) {
                stream = await navigator.mediaDevices.getUserMedia({ audio: true })
                }
            if (!mediaRecorder) {
                mediaRecorder = new MediaRecorder(stream)
    
                mediaRecorder.ondataavailable = async (e) => {
                    if (e.data.size > 0) {
                        fetch("http://localhost:8080/audio", {
                            method: "POST",
                            headers: {
                                "Room-Code": roomCode,
                                "Content-Type": e.data.type,
                                'X-Mime-Type': e.data.type
                            },
                            body: e.data
                        })
                        .catch(err => console.error("Error sending audio chunk:", err))
                    }
                }
            }

            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)()

                scriptProcessor = audioContext.createScriptProcessor(4096, 1, 1);
                scriptProcessor.connect(audioContext.destination);

                scriptProcessor.onaudioprocess = async (event) => {
                    if (audioQueue.length > 0 && audioContext.state === 'running') {
                        const audioBlob = audioQueue.shift();

                        try {
                            const arrayBuffer = await audioBlob.arrayBuffer();
                            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

                            const source = audioContext.createBufferSource();
                            source.buffer = audioBuffer;
                            source.connect(audioContext.destination);
                            source.start(0);
                        } catch (e) {
                            console.error("Error decoding or playing audio chunk:", e);
                        }
                    } else if (audioQueue.length === 0 && isPlaying) {
                        // If queue is empty and was playing, we might have a gap.
                        // Consider pausing or stopping playback here if silence is desired.
                    }
                };
            }
        }

        const gameCard = document.querySelector('.game-card');
        let floatDirection = 1;
        
        setInterval(() => {
            if (!gameCard.matches(':hover')) {
                const currentTransform = gameCard.style.transform.match(/translateY\(([^)]+)\)/);
                const currentY = currentTransform ? parseFloat(currentTransform[1]) : 0;
                
                if (currentY >= 2) floatDirection = -1;
                if (currentY <= -2) floatDirection = 1;
                
                gameCard.style.transform = `translateY(${currentY + (floatDirection * 0.05)}px)`;
            }
        }, 100);
    </script>
</body>
</html>
